<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js AR/XR - Enhanced Virtual Art Gallery</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body, html { margin: 0; height: 100%; overflow: hidden; }
        canvas { width: 100%; height: 100%; display: block; }
    </style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "../lib/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from '../lib/controls/OrbitControls.js';
import { ARButton } from '../lib/webxr/ARButton.js';

let camera, scene, renderer;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function initGallery() {
    scene = new THREE.Scene();
    camera = setupCamera();
    renderer = setupRenderer();

    setupLighting();
    setupControls();
    setupGallery();
    setupEventListeners();
    animate();
}

function setupCamera() {
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
    camera.position.set(0, 1.6, 3);
    return camera;
}

function setupRenderer() {
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(ARButton.createButton(renderer));
    return renderer;
}

function setupLighting() {
    const ambientLight = new THREE.HemisphereLight(0xddeeff, 0x202020, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);
}

function setupControls() {
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.6, 0);
    controls.update();
}

function setupGallery() {
    createGalleryBoundaries(scene);
    createCheckerboardFloor(scene);
    loadArtPieces(scene);
}

function createGalleryBoundaries(scene) {
    const whiteMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
    const blackMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

    const boundaryHeight = 2;
    const boundaryWidth = 1;
    const roomSize = 10;
    const tilesPerSide = roomSize / boundaryWidth; // assuming the wall boundaryWidth matches the floor tile size

    // Calculate wall colors to match the checkerboard floor
    for (let i = 0; i < tilesPerSide; i++) {
        for (let j = 0; j < tilesPerSide; j++) {
            const geometry = new THREE.PlaneGeometry(boundaryWidth, boundaryHeight);
            // Calculate material based on checkerboard pattern
            const material = ((i + j) % 2 === 0) ? blackMaterial : whiteMaterial;

            // Front wall
            const frontWall = new THREE.Mesh(geometry, material);
            frontWall.position.set(i - roomSize / 2 + boundaryWidth / 2, boundaryHeight / 2, -roomSize / 2);
            frontWall.rotation.y = Math.PI; // Rotate to face inside
            scene.add(frontWall);

            // Back wall
            const backWall = new THREE.Mesh(geometry, material);
            backWall.position.set(i - roomSize / 2 + boundaryWidth / 2, boundaryHeight / 2, roomSize / 2);
            scene.add(backWall);

            // Left wall
            const leftWall = new THREE.Mesh(geometry, material);
            leftWall.position.set(-roomSize / 2, boundaryHeight / 2, j - roomSize / 2 + boundaryWidth / 2);
            leftWall.rotation.y = -Math.PI / 2; // Rotate to face inside
            scene.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(geometry, material);
            rightWall.position.set(roomSize / 2, boundaryHeight / 2, j - roomSize / 2 + boundaryWidth / 2);
            rightWall.rotation.y = Math.PI / 2; // Rotate to face inside
            scene.add(rightWall);
        }
    }
}

function createWallPositions(width, height, size) {
    const planesPerWall = Math.ceil(size / width);
    const halfSize = size / 2;
    const wallPositions = [];
    const numberOfRows = 2; // Number of vertical rows of walls
    const totalHeight = height * numberOfRows; // Total height after stacking walls

    // Adjustments to include a second row of walls
    for (let row = 0; row < numberOfRows; row++) {
        // Front and Back walls
        for (let i = 0; i < planesPerWall; i++) {
            wallPositions.push({
                position: [-halfSize + i * width + width / 2, (height / 2) + (row * height), -halfSize],
                rotation: 0,
                rowIndex: row,
                colIndex: i
            });
            wallPositions.push({
                position: [-halfSize + i * width + width / 2, (height / 2) + (row * height), halfSize],
                rotation: Math.PI,
                rowIndex: row,
                colIndex: i
            });
        }

        // Left and Right walls
        for (let i = 0; i < planesPerWall; i++) {
            wallPositions.push({
                position: [-halfSize, (height / 2) + (row * height), -halfSize + i * width + width / 2],
                rotation: Math.PI / 2,
                rowIndex: row,
                colIndex: 0
            });
            wallPositions.push({
                position: [halfSize, (height / 2) + (row * height), -halfSize + i * width + width / 2],
                rotation: -Math.PI / 2,
                rowIndex: row,
                colIndex: 0
            });
        }
    }

    return wallPositions;
}

function createCheckerboardFloor(scene) {    
        // Checkerboard Floor with PBR
        const tileSize = 1;
        const tilesPerSide = 10;
        const checkerboardGroup = new THREE.Group();
        for (let x = 0; x < tilesPerSide; x++) {
            for (let z = 0; z < tilesPerSide; z++) {
                const geometry = new THREE.PlaneGeometry(tileSize, tileSize);
                const material = new THREE.MeshStandardMaterial({
                    color: (x + z) % 2 === 0 ? 0x000000 : 0xffffff,
                    side: THREE.DoubleSide
                });
                const tile = new THREE.Mesh(geometry, material);
                tile.castShadow = true;
                tile.receiveShadow = true;
                tile.position.x = (x - tilesPerSide / 2) * tileSize + tileSize / 2;
                tile.position.z = (z - tilesPerSide / 2) * tileSize + tileSize / 2;
                tile.rotation.x = -Math.PI / 2;
                checkerboardGroup.add(tile);
            }
        }
        checkerboardGroup.position.y = -0.01;
        scene.add(checkerboardGroup);
    }

    function loadArtPieces(scene) {
        const textureLoader = new THREE.TextureLoader();
        const artGeometry = new THREE.PlaneGeometry(2, 2);
        textureLoader.load('BackWater.png', function(texture) {
            const artMaterial = new THREE.MeshStandardMaterial({map: texture});
            const art = new THREE.Mesh(artGeometry, artMaterial);
            art.castShadow = true;
            art.position.set(0, 2, -4.99);
            art.userData = { clickable: true }; // Mark art as clickable
            scene.add(art);

            // Event listener for double click/tap
            art.addEventListener('dblclick', function(event) {
                translateCameraToArt(art.position);
            }, false);
        });
    }

    function onDoubleClick(event) {
        // Calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Now, check for intersections
        checkForIntersections();
    }

    function translateCameraToArt(targetPosition) {
        const startPosition = camera.position.clone();
        const endPosition = targetPosition.clone();
        endPosition.y = camera.position.y; // Keep the camera at the same height
        let alpha = 0.0;

        function animate() {
            if (alpha < 1.0) {
                alpha += 0.01; // Speed of the camera movement
                camera.position.lerpVectors(startPosition, endPosition, alpha);
                camera.lookAt(targetPosition); // Ensure the camera still looks at the target
                requestAnimationFrame(animate);
            }
        }
        animate();
    }


    function checkForIntersections() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children);

        for (let i = 0; i < intersects.length; i++) {
            if (intersects[i].object.userData.clickable) {
                translateCameraToArt(intersects[i].object.position);
                break; // Assuming you want to interact with the first object the ray hits that is clickable
            }
        }
    }

function onWindowResize(camera, renderer) {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function setupEventListeners() {
    window.addEventListener('resize', () => onWindowResize(camera, renderer), false);
    document.addEventListener('dblclick', onDoubleClick, false);
}

function animate() {
    renderer.setAnimationLoop(() => render());
}

function render() {
    renderer.render(scene, camera);
}

initGallery();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js XR - Enhanced Virtual Art Gallery</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "../lib/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from '../lib/controls/OrbitControls.js';
import { XRButton } from '../lib/webxr/XRButton.js';

let camera, scene, renderer, controls;

init();
animate();

function init() {
    const container = document.createElement('div');
    document.body.appendChild(container);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
    camera.position.set(0, 1.6, 3);

    const ambientLight = new THREE.HemisphereLight(0xddeeff, 0x202020, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.6, 0);
    controls.update();

    document.body.appendChild(XRButton.createButton(renderer));

    createGalleryBoundaries();
    createCheckerboardFloor();
    loadArtPieces();

    function createGalleryBoundaries() {
        const boundaryMaterial = new THREE.MeshStandardMaterial({color: 0xffffff});
        // Updated size for modular design
        const boundaryHeight = 2; // Two units tall
        const boundaryWidth = 1; // One unit wide

        // Modular walls array to define room size
        const walls = [
            // Front walls
            { pos: [boundaryWidth, boundaryHeight / 2, -5], rot: Math.PI / 2 },
            { pos: [-boundaryWidth, boundaryHeight / 2, -5], rot: Math.PI / 2 },
            // Back walls
            { pos: [boundaryWidth, boundaryHeight / 2, 5], rot: -Math.PI / 2 },
            { pos: [-boundaryWidth, boundaryHeight / 2, 5], rot: -Math.PI / 2 },
            // Left walls
            { pos: [-5, boundaryHeight / 2, boundaryWidth], rot: 0 },
            { pos: [-5, boundaryHeight / 2, -boundaryWidth], rot: 0 },
            // Right walls
            { pos: [5, boundaryHeight / 2, boundaryWidth], rot: Math.PI },
            { pos: [5, boundaryHeight / 2, -boundaryWidth], rot: Math.PI }
        ];

        // Create and position walls based on the modular design
        walls.forEach(wallData => {
            const geometry = new THREE.PlaneGeometry(boundaryWidth, boundaryHeight);
            const wall = new THREE.Mesh(geometry, boundaryMaterial);
            wall.position.set(...wallData.pos);
            wall.rotation.y = wallData.rot;
            scene.add(wall);
        });
    }

    function createCheckerboardFloor() {    
        // Checkerboard Floor with PBR
        const tileSize = 1;
        const tilesPerSide = 10;
        const checkerboardGroup = new THREE.Group();
        for (let x = 0; x < tilesPerSide; x++) {
            for (let z = 0; z < tilesPerSide; z++) {
                const geometry = new THREE.PlaneGeometry(tileSize, tileSize);
                const material = new THREE.MeshStandardMaterial({
                    color: (x + z) % 2 === 0 ? 0x000000 : 0xffffff,
                    side: THREE.DoubleSide
                });
                const tile = new THREE.Mesh(geometry, material);
                tile.castShadow = true;
                tile.receiveShadow = true;
                tile.position.x = (x - tilesPerSide / 2) * tileSize + tileSize / 2;
                tile.position.z = (z - tilesPerSide / 2) * tileSize + tileSize / 2;
                tile.rotation.x = -Math.PI / 2;
                checkerboardGroup.add(tile);
            }
        }
        checkerboardGroup.position.y = -0.01;
        scene.add(checkerboardGroup);
    }

    function loadArtPieces() {
    const textureLoader = new THREE.TextureLoader();
    const artGeometry = new THREE.PlaneGeometry(2, 2);
    textureLoader.load('BackWater.png', function(texture) {
        const artMaterial = new THREE.MeshStandardMaterial({map: texture});
        const art = new THREE.Mesh(artGeometry, artMaterial);
        art.castShadow = true;
        art.position.set(0, 2, -4.99);
        scene.add(art);
    });

}

    window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    renderer.setAnimationLoop(render);
}

function render() {
    renderer.render(scene, camera);
}
</script>

</body>
</html>
